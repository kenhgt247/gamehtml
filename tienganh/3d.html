<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pick the Right Item 3D - Kids Vocab</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        /* --- CSS STYLES --- */
        html, body {
            overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            background-color: #B3E5FC; /* Softer Sky Blue */
            user-select: none; -webkit-user-select: none; touch-action: none;
        }
        #renderCanvas { width: 100%; height: 100%; outline: none; }
        
        /* UI Overlay Layers */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas by default */
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        /* Generic Screen Style (Start/Win) */
        .screen {
            pointer-events: auto; background: rgba(255, 255, 255, 0.95);
            border-radius: 25px; padding: 30px; text-align: center;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2); border: 5px solid #4FC3F7;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            min-width: 320px; display: none;
        }
        .visible { display: block !important; animation: popUp 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28); }
        @keyframes popUp { from {transform: translate(-50%, -60%) scale(0.8); opacity:0;} to {transform: translate(-50%, -50%) scale(1); opacity:1;} }

        h1 { color: #0288D1; font-size: 2.8rem; margin-bottom: 10px; }
        h2 { color: #009688; font-size: 2.2rem; margin: 15px 0; }
        p { color: #546E7A; font-size: 1.3rem; font-weight: bold;}

        /* Buttons */
        button {
            background: #FFEB3B; border: none; border-bottom: 6px solid #FBC02D;
            color: #333; padding: 15px 35px; font-size: 1.3rem; font-weight: 900;
            border-radius: 50px; margin: 10px; cursor: pointer; transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); border-bottom-width: 2px; }
        button.primary { background: #FF5722; border-color: #E64A19; color: white; font-size: 1.5rem;}
        
        /* In-Game HUD */
        #hud { display: none; padding: 20px; pointer-events: none; }
        .top-bar { display: flex; justify-content: space-between; align-items: center; }
        .stat-box { background: #FFF9C4; padding: 10px 20px; border-radius: 25px; font-weight: 900; font-size: 1.4rem; color: #333; border: 3px solid #FBC02D; box-shadow: 0 4px 0 rgba(0,0,0,0.1); }
        
        /* Task Card (Bottom center) */
        #task-card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: white; padding: 15px 40px; border-radius: 40px;
            border: 5px solid #0288D1; display: flex; align-items: center; gap: 20px;
            pointer-events: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        #target-word { font-size: 2.5rem; font-weight: 900; color: #D81B60; text-transform: uppercase; letter-spacing: 2px;}
        #speaker-btn { font-size: 2rem; cursor: pointer; background: #B2EBF2; border-radius: 50%; width: 60px; height: 60px; line-height: 60px; text-align: center; border: 3px solid #00BCD4; }
        
        /* Feedback Overlay (Correct/Wrong text) */
        #feedback {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; font-weight: 900; text-shadow: 4px 4px 0 #fff, -4px -4px 0 #fff, 4px -4px 0 #fff, -4px 4px 0 #fff;
            display: none; pointer-events: none; white-space: nowrap; z-index: 100;
        }
        .win-text { color: #76FF03; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .lose-text { color: #FF1744; animation: shakeText 0.5s ease-in-out; }
        @keyframes popIn { 0% { transform: translate(-50%, -50%) scale(0); } 100% { transform: translate(-50%, -50%) scale(1); } }
        @keyframes shakeText { 0%, 100% {transform: translate(-50%, -50%);} 20%, 60% {transform: translate(-52%, -50%);} 40%, 80% {transform: translate(-48%, -50%);}}
    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <div id="ui-layer">
        <div id="hud">
            <div class="top-bar">
                <div class="stat-box">Level: <span id="level-display">1</span></div>
                <button onclick="game.resetGame()" style="padding: 8px 20px; font-size: 1rem; margin:0; border-bottom-width:4px;">Home üè†</button>
                <div class="stat-box" style="background:#C8E6C9; border-color:#388E3C">Score: <span id="score-display">0</span></div>
            </div>
        </div>

        <div id="feedback">Great Job!</div>

        <div id="task-card" style="display:none;">
            <div id="speaker-btn" onclick="game.speakCurrentWord()">üá¨üáß üîä</div>
            <div id="target-word">APPLE</div>
        </div>

        <div id="start-screen" class="screen visible">
            <h1>Pick the Right Item!</h1>
            <p>Listen to the British voice and find the object.</p>
            
            <div style="margin: 25px 0; background: #E1F5FE; padding: 15px; border-radius: 20px;">
                <p style="margin-bottom:10px; font-size: 1.1rem; color:#0277BD">How many items?</p>
                <button onclick="game.setDifficulty('easy')" id="btn-easy" style="font-size:1.1rem; padding: 10px 20px;">Easy (5)</button>
                <button onclick="game.setDifficulty('normal')" id="btn-normal" style="font-size:1.1rem; padding: 10px 20px; opacity:1;">Normal (8)</button>
                <button onclick="game.setDifficulty('hard')" id="btn-hard" style="font-size:1.1rem; padding: 10px 20px;">Hard (12)</button>
            </div>
            
            <button class="primary" onclick="game.startGame()">PLAY GAME ‚ñ∂</button>
        </div>

        <div id="win-screen" class="screen">
            <h1>üéâ YAY! YOU WIN! üéâ</h1>
            <h2 id="final-score">Score: 100</h2>
            <p>You are super smart!</p>
            <button class="primary" onclick="game.showStartScreen()">Play Again ‚Ü∫</button>
        </div>
    </div>

    <script>
        /**
         * DATABASE V·ª∞NG & MAPPING H√åNH ·∫¢NH
         * T·∫≠p trung v√†o Hoa qu·∫£, H√¨nh kh·ªëi, S·ªë ƒë·∫øm, ƒê·ªì v·∫≠t quen thu·ªôc.
         */
        const WORDS_DB = {
            // --- FRUITS ---
            "APPLE": { color: "#F44336", type: "fruit_sphere", detail: "stem" },
            "BANANA": { color: "#FFEB3B", type: "fruit_curved" },
            "ORANGE": { color: "#FF9800", type: "fruit_rough" },
            "GRAPE": { color: "#9C27B0", type: "fruit_cluster" },
            "PEAR": { color: "#CDDFA0", type: "fruit_pear" },
            "LEMON": { color: "#FFF176", type: "fruit_oval" },

            // --- SHAPES (H√¨nh h·ªçc ph·∫≥ng & kh·ªëi) ---
            "CIRCLE": { color: "#2196F3", type: "shape_disc" },
            "SQUARE": { color: "#00BCD4", type: "shape_tile", sides: 4 },
            "TRIANGLE": { color: "#FFC107", type: "shape_tile", sides: 3 },
            "STAR": { color: "#FFD700", type: "shape_star" },
            "CUBE": { color: "#3F51B5", type: "box" },
            "SPHERE": { color: "#E91E63", type: "sphere" },

            // --- NUMBERS (Hi·ªÉn th·ªã b·∫±ng s·ªë l∆∞·ª£ng v·∫≠t th·ªÉ) ---
            "ONE":   { color: "#5C6BC0", type: "count", quantity: 1 },
            "TWO":   { color: "#42A5F5", type: "count", quantity: 2 },
            "THREE": { color: "#26A69A", type: "count", quantity: 3 },
            "FOUR":  { color: "#66BB6A", type: "count", quantity: 4 },
            "FIVE":  { color: "#FFA726", type: "count", quantity: 5 },

            // --- OBJECTS ---
            "BALL": { color: "#FF5722", type: "sphere", detail: "stripes" },
            "BOX": { color: "#795548", type: "box" },
            "CAR": { color: "#D32F2F", type: "car" },
            "BOOK": { color: "#1565C0", type: "book" },
            "CHAIR": { color: "#8D6E63", type: "chair" },
            "CUP": { color: "#03A9F4", type: "cup" },
            "SPOON": { color: "#B0BEC5", type: "spoon" }
        };

        const KEY_LIST = Object.keys(WORDS_DB);

        // --- KH·ªûI T·∫†O ENGINE BABYLON.JS ---
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        
        // --- H·ªÜ TH·ªêNG √ÇM THANH (Web Audio & Speech Synthesis) ---
        const synth = window.speechSynthesis;
        let britishVoice = null;

        // C·ªë g·∫Øng t·∫£i gi·ªçng Anh-Anh khi tr√¨nh duy·ªát s·∫µn s√†ng
        window.speechSynthesis.onvoiceschanged = () => {
             const voices = window.speechSynthesis.getVoices();
             // T√¨m gi·ªçng c√≥ lang ch·ª© 'GB' ho·∫∑c 'UK'
             britishVoice = voices.find(v => v.lang.includes('GB') || v.lang.includes('UK'));
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // H√†m t·∫°o hi·ªáu ·ª©ng √¢m thanh beep/ting ƒë∆°n gi·∫£n
        function playSoundfx(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            if (type === 'win') {
                // Sound: Ting ting!
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.setValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'lose') {
                // Sound: Bonk!
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            }
        }

        // --- GAME LOGIC MAIN CLASS ---
        class Game {
            constructor() {
                this.scene = null;
                this.level = 1;
                this.score = 0;
                this.totalLevels = 10;
                this.itemsCount = 8; // M·∫∑c ƒë·ªãnh Normal
                this.targetWord = "";
                this.isProcessing = false; // Ch·∫∑n click khi ƒëang x·ª≠ l√Ω ƒë√∫ng/sai
                this.currentMeshes = [];
                this.initEngine();
            }

            initEngine() {
                this.scene = new BABYLON.Scene(engine);
                this.scene.clearColor = BABYLON.Color3.FromHexString("#B3E5FC");
                
                // Camera: G√≥c nh√¨n t·ª´ tr√™n cao xu·ªëng m·ªôt ch√∫t
                const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 3, 18, BABYLON.Vector3.Zero(), this.scene);
                camera.attachControl(canvas, true);
                // V√¥ hi·ªáu h√≥a zoom v√† pan ƒë·ªÉ b√© kh√¥ng l√†m h·ªèng g√≥c nh√¨n
                camera.inputs.remove(camera.inputs.attached.mousewheel);
                camera.inputs.remove(camera.inputs.attached.pointers); 
                // Gi·ªõi h·∫°n g√≥c quay
                camera.lowerRadiusLimit = 15; camera.upperRadiusLimit = 20;
                camera.lowerBetaLimit = 0.5; camera.upperBetaLimit = 1.2;

                // √Ånh s√°ng: T∆∞∆°i s√°ng, ho·∫°t h√¨nh
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0.5, 1, 0), this.scene);
                light.intensity = 0.8; light.groundColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.5), this.scene);
                dirLight.intensity = 0.6;

                // H·ªá th·ªëng h·∫°t Confetti (Ph√°o hoa gi·∫•y)
                this.confettiSystem = new BABYLON.ParticleSystem("confetti", 1500, this.scene);
                this.confettiSystem.particleTexture = new BABYLON.Texture("https://i.imgur.com/0g6kjN0.png", this.scene); // Texture ch·∫•m tr√≤n tr·∫Øng ƒë∆°n gi·∫£n
                this.confettiSystem.emitter = BABYLON.Vector3.Zero();
                this.confettiSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5); this.confettiSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 0.5);
                // M√†u s·∫Øc ƒëa d·∫°ng
                this.confettiSystem.color1 = BABYLON.Color4.FromHexString("#F44336FF");
                this.confettiSystem.color2 = BABYLON.Color4.FromHexString("#FFEB3BFF");
                this.confettiSystem.colorDead = new BABYLON.Color4(0, 0, 1, 0.0);
                this.confettiSystem.minSize = 0.1; this.confettiSystem.maxSize = 0.3;
                this.confettiSystem.minLifeTime = 0.5; this.confettiSystem.maxLifeTime = 2.0;
                this.confettiSystem.emitRate = 0; // Ch·ªâ ph√°t khi g·ªçi
                this.confettiSystem.gravity = new BABYLON.Vector3(0, -8, 0);
                this.confettiSystem.direction1 = new BABYLON.Vector3(-2, 4, -2);
                this.confettiSystem.direction2 = new BABYLON.Vector3(2, 6, 2);
                this.confettiSystem.start();

                // X·ª≠ l√Ω s·ª± ki·ªán Click/Tap v√†o ƒë·ªì v·∫≠t
                this.scene.onPointerDown = (evt, pickResult) => {
                    if (this.isProcessing) return;
                    if (pickResult.hit && pickResult.pickedMesh) {
                        // T√¨m mesh cha g·ªëc ch·ª©a d·ªØ li·ªáu t·ª´ v·ª±ng
                        let rootMesh = pickResult.pickedMesh;
                        while (rootMesh.parent && rootMesh.metadata === null) { 
                            rootMesh = rootMesh.parent; 
                        }
                        if (rootMesh.metadata && rootMesh.metadata.word) {
                            this.handlePick(rootMesh);
                        }
                    }
                };

                // V√≤ng l·∫∑p render
                engine.runRenderLoop(() => {
                    this.scene.render();
                    camera.alpha += 0.0005; // Xoay camera c·ª±c ch·∫≠m cho sinh ƒë·ªông
                });
                window.addEventListener("resize", () => engine.resize());
            }

            // Ch·ªçn ƒë·ªô kh√≥
            setDifficulty(diff) {
                document.querySelectorAll("#start-screen button[id^='btn-']").forEach(b => b.style.opacity = '0.5');
                document.getElementById(`btn-${diff}`).style.opacity = '1';
                if (diff === 'easy') this.itemsCount = 5;
                if (diff === 'normal') this.itemsCount = 8;
                if (diff === 'hard') this.itemsCount = 12;
            }

            showStartScreen() {
                document.getElementById('start-screen').classList.add('visible');
                document.getElementById('win-screen').classList.remove('visible');
                document.getElementById('hud').style.display = 'none';
                document.getElementById('task-card').style.display = 'none';
                this.clearScene();
            }

            startGame() {
                this.score = 0; this.level = 1;
                document.getElementById('start-screen').classList.remove('visible');
                document.getElementById('hud').style.display = 'block';
                document.getElementById('task-card').style.display = 'flex';
                this.updateHud();
                this.startLevel();
            }

            resetGame() { this.showStartScreen(); }
            updateHud() {
                document.getElementById('level-display').innerText = this.level + "/" + this.totalLevels;
                document.getElementById('score-display').innerText = this.score;
            }

            // --- CH·ª®C NƒÇNG ƒê·ªåC T·ª™ (QUAN TR·ªåNG: GI·ªåNG ANH-ANH) ---
            speakCurrentWord() {
                if (synth.speaking) { synth.cancel(); }
                const utterThis = new SpeechSynthesisUtterance(this.targetWord);
                
                // Th·ª≠ l·∫•y l·∫°i danh s√°ch gi·ªçng n·∫øu ch∆∞a t√¨m th·∫•y l√∫c ƒë·∫ßu
                if (!britishVoice) {
                     const voices = window.speechSynthesis.getVoices();
                     britishVoice = voices.find(v => v.lang.includes('GB') || v.lang.includes('UK'));
                }

                // G√°n gi·ªçng n·∫øu t√¨m th·∫•y
                if (britishVoice) {
                    utterThis.voice = britishVoice;
                }
                
                utterThis.rate = 0.85; // ƒê·ªçc ch·∫≠m h∆°n m·ªôt ch√∫t cho tr·∫ª
                utterThis.pitch = 1.1; // Gi·ªçng cao h∆°n m·ªôt ch√∫t, vui v·∫ª
                synth.speak(utterThis);
            }

            clearScene() {
                // X√≥a c√°c mesh c≈©
                this.currentMeshes.forEach(m => { if(m) m.dispose(false, true); });
                this.currentMeshes = [];
            }

            // --- B·∫ÆT ƒê·∫¶U M√ÄN CH∆†I ---
            startLevel() {
                this.isProcessing = false;
                this.clearScene();

                // 1. Ch·ªçn t·ª´ m·ª•c ti√™u ng·∫´u nhi√™n
                this.targetWord = KEY_LIST[Math.floor(Math.random() * KEY_LIST.length)];
                document.getElementById('target-word').innerText = this.targetWord;
                
                // T·ª± ƒë·ªông ƒë·ªçc sau 0.6s
                setTimeout(() => this.speakCurrentWord(), 600);

                // 2. T·∫°o danh s√°ch item (M·ª•c ti√™u + Nhi·ªÖu)
                let itemsToSpawn = [this.targetWord];
                let distractorPool = KEY_LIST.filter(k => k !== this.targetWord).sort(() => 0.5 - Math.random());
                // L·∫•y th√™m c√°c item nhi·ªÖu
                for(let i=0; i < this.itemsCount - 1; i++) {
                    itemsToSpawn.push(distractorPool[i % distractorPool.length]);
                }
                // X√°o tr·ªôn danh s√°ch v·ªã tr√≠
                itemsToSpawn.sort(() => 0.5 - Math.random());

                // 3. Sinh ra c√°c v·∫≠t th·ªÉ 3D
                this.spawnItems(itemsToSpawn);
            }

            spawnItems(items) {
                const range = 7; // B√°n k√≠nh ph√¢n b·ªë
                items.forEach((word, index) => {
                    const mesh = this.createMeshForWord(word);
                    if(!mesh) return;

                    // S·ª≠ d·ª•ng ph√¢n b·ªë Golden Angle ƒë·ªÉ tr√°nh ch·ªìng ch√©o v√† tr√¥ng t·ª± nhi√™n
                    const phi = Math.acos( -1 + ( 2 * index ) / items.length );
                    const theta = Math.sqrt( items.length * Math.PI ) * phi;
                    
                    mesh.position.x = range * Math.cos( theta ) * Math.sin( phi );
                    // Thay ƒë·ªïi ƒë·ªô cao nh·∫π
                    mesh.position.y = (Math.random() * 2) - 1.5; 
                    mesh.position.z = range * Math.sin( theta ) * Math.sin( phi );
                    
                    // H∆∞·ªõng m·∫∑t v·ªÅ trung t√¢m (n∆°i camera nh√¨n)
                    mesh.lookAt(BABYLON.Vector3.Zero());
                    // ƒêi·ªÅu ch·ªânh l·∫°i rotation ƒë·ªÉ v·∫≠t ƒë·ª©ng th·∫≥ng sau khi lookAt
                    mesh.rotation.x = 0; mesh.rotation.z = 0;

                    // Hi·ªáu ·ª©ng xu·∫•t hi·ªán (Pop-in animation)
                    mesh.scaling = BABYLON.Vector3.Zero();
                    const anim = new BABYLON.Animation("pop", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
                    anim.setKeys([{frame:0, value: BABYLON.Vector3.Zero()}, {frame:15, value: new BABYLON.Vector3(1.2, 1.2, 1.2)}, {frame:25, value: new BABYLON.Vector3(1, 1, 1)}]);
                    mesh.animations.push(anim);
                    this.scene.beginAnimation(mesh, 0, 25, false);
                    
                    // G·∫Øn d·ªØ li·ªáu t·ª´ v·ª±ng v√†o mesh ƒë·ªÉ ki·ªÉm tra khi click
                    mesh.metadata = { word: word };
                    this.currentMeshes.push(mesh);
                });
            }

            // --- X·ª¨ L√ù KHI CH·ªåN ---
            handlePick(mesh) {
                const pickedWord = mesh.metadata.word;
                if (pickedWord === this.targetWord) {
                    this.onWin(mesh);
                } else {
                    this.onLose(mesh);
                }
            }

            // KHI CH·ªåN ƒê√öNG
            onWin(mesh) {
                this.isProcessing = true; // Kh√≥a input
                playSoundfx('win');
                this.score += 10; this.updateHud();
                
                // Hi·ªáu ·ª©ng vi·ªÅn s√°ng (Glow)
                const hl = new BABYLON.HighlightLayer("hl", this.scene);
                hl.addMesh(mesh, BABYLON.Color3.Green());
                hl.blurHorizontalSize = 2; hl.blurVerticalSize = 2;

                // Hi·ªán text khen ng·ª£i
                const fb = document.getElementById('feedback');
                fb.innerText = ["Brilliant!", "Fantastic!", "Well Done!", "Correct!"][Math.floor(Math.random()*4)];
                fb.className = 'win-text'; fb.style.display = 'block';

                // B·∫Øn ph√°o hoa t·∫°i v·ªã tr√≠ v·∫≠t
                this.confettiSystem.emitter = mesh.position;
                this.confettiSystem.manualEmitCount = 400;
                
                // V·∫≠t xoay vui v·∫ª
                BABYLON.Animation.CreateAndStartAnimation("spinWin", mesh, "rotation.y", 30, 45, mesh.rotation.y, mesh.rotation.y + Math.PI*4, 0, new BABYLON.BackEase());

                // Chuy·ªÉn m√†n sau 2 gi√¢y
                setTimeout(() => {
                    hl.dispose(); fb.style.display = 'none';
                    this.nextLevel();
                }, 2000);
            }

            // KHI CH·ªåN SAI
            onLose(mesh) {
                playSoundfx('lose');
                const fb = document.getElementById('feedback');
                fb.innerText = "Try again!";
                fb.className = 'lose-text'; fb.style.display = 'block';
                
                // Hi·ªáu ·ª©ng rung l·∫Øc
                const startX = mesh.position.x;
                BABYLON.Animation.CreateAndStartAnimation("shake", mesh, "position.x", 60, 20, startX, startX, 0, null, () => {
                     mesh.position.x = startX; // Reset v·ªã tr√≠ sau khi rung
                });
                // Keyframe rung th·ªß c√¥ng cho control t·ªët h∆°n
                const animShake = new BABYLON.Animation("shakeX", "position.x", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
                animShake.setKeys([
                    { frame: 0, value: startX }, { frame: 4, value: startX + 0.4 }, { frame: 8, value: startX - 0.4 },
                    { frame: 12, value: startX + 0.3 }, { frame: 16, value: startX - 0.3 }, { frame: 20, value: startX }
                ]);
                mesh.animations = [animShake]; // Ghi ƒë√® animation c≈©
                this.scene.beginAnimation(mesh, 0, 20, false);

                // ƒê·ªïi m√†u ƒë·ªè t·∫°m th·ªùi
                mesh.getChildMeshes().concat(mesh).forEach(c => {
                    if(c.material && c.material.diffuseColor) {
                        c.savedColor = c.material.diffuseColor.clone(); // L∆∞u m√†u c≈©
                        c.material.diffuseColor = BABYLON.Color3.Red();
                    }
                });

                setTimeout(() => {
                    fb.style.display = 'none';
                    // Tr·∫£ l·∫°i m√†u c≈©
                    mesh.getChildMeshes().concat(mesh).forEach(c => {
                        if(c.savedColor) c.material.diffuseColor = c.savedColor;
                    });
                }, 1000);
            }

            nextLevel() {
                this.level++;
                if (this.level > this.totalLevels) {
                    this.showWinScreen();
                } else {
                    this.updateHud(); this.startLevel();
                }
            }

            showWinScreen() {
                document.getElementById('hud').style.display = 'none';
                document.getElementById('task-card').style.display = 'none';
                document.getElementById('win-screen').classList.add('visible');
                document.getElementById('final-score').innerText = "Total Score: " + this.score;
                this.clearScene(); playSoundfx('win');
            }

            // --- FACTORY: T·∫†O MESH D·ª∞A TR√äN T·ª™ V·ª∞NG ---
            createMeshForWord(word) {
                const data = WORDS_DB[word] || WORDS_DB["BOX"]; // Fallback n·∫øu l·ªói
                const mainMat = new BABYLON.StandardMaterial(word + "Mat", this.scene);
                mainMat.diffuseColor = BABYLON.Color3.FromHexString(data.color);
                mainMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Gi·∫£m ƒë·ªô b√≥ng
                
                let mesh = null; // Mesh cha ch√≠nh

                // Helper t·∫°o cu·ªëng l√° cho hoa qu·∫£
                const addStem = (parentMesh) => {
                    const stem = BABYLON.MeshBuilder.CreateCylinder("stem", {height:0.5, diameter:0.15}, this.scene);
                    stem.material = new BABYLON.StandardMaterial("brown", this.scene); stem.material.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0);
                    stem.parent = parentMesh; stem.position.y = 0.8;
                    if(Math.random()>0.5){
                        const leaf = BABYLON.MeshBuilder.CreateSphere("leaf",{diameter:0.4, segments:4},this.scene);
                        leaf.scaling.y = 0.1; leaf.material=new BABYLON.StandardMaterial("g",this.scene);leaf.material.diffuseColor=BABYLON.Color3.Green();
                        leaf.parent=stem; leaf.position.y=0.2; leaf.position.x=0.2; leaf.rotation.z=0.5;
                    }
                }

                switch(data.type) {
                    // --- FRUITS ---
                    case "fruit_sphere": // Apple
                        mesh = BABYLON.MeshBuilder.CreateSphere(word, {diameter: 1.6, segments: 16}, this.scene);
                        if(data.detail === "stem") addStem(mesh);
                        break;
                    case "fruit_rough": // Orange
                        mesh = BABYLON.MeshBuilder.CreateSphere(word, {diameter: 1.5, segments: 8}, this.scene); // √çt segment ƒë·ªÉ tr√¥ng s·∫ßn s√πi
                        break;
                    case "fruit_curved": // Banana
                        mesh = new BABYLON.Mesh("banana_root", this.scene); // Mesh ·∫£o l√†m cha
                        const curve = BABYLON.MeshBuilder.CreateTorus("b", {diameter: 2, thickness: 0.6, tessellation: 16}, this.scene);
                        // C·∫Øt l·∫•y m·ªôt ph·∫ßn c·ªßa h√¨nh xuy·∫øn ƒë·ªÉ t·∫°o ƒë·ªô cong
                        const cutter = BABYLON.MeshBuilder.CreateBox("cutter", {size:3}, this.scene);
                        cutter.position.x = 1.5;
                        // L∆∞u √Ω: Web kh√¥ng d√πng CSG (ph·ª©c t·∫°p), d√πng c√°ch che th·ªß c√¥ng ho·∫∑c ch·∫•p nh·∫≠n torus nguy√™n.
                        // ƒê∆°n gi·∫£n h√≥a: D√πng Cylinder cong nh·∫π
                        curve.dispose(); cutter.dispose();
                        mesh = BABYLON.MeshBuilder.CreateCylinder(word, {height:2, diameterTop:0.4, diameterBottom:0.4}, this.scene);
                        mesh.rotation.z = Math.PI/6;
                        // Th√™m 2 ƒë·∫ßu nh·ªè m√†u n√¢u/xanh
                        const tip1 = BABYLON.MeshBuilder.CreateSphere("t1",{diameter:0.45},this.scene); tip1.parent=mesh; tip1.position.y=1;
                        tip1.material = new BABYLON.StandardMaterial("tg",this.scene); tip1.material.diffuseColor=new BABYLON.Color3(0.5,0.8,0.2);
                        break;
                     case "fruit_pear":
                        mesh = BABYLON.MeshBuilder.CreateSphere("pear_bot", {diameter: 1.6, slice: 0.6}, this.scene);
                        const topPear = BABYLON.MeshBuilder.CreateSphere("pear_top", {diameter: 1.1}, this.scene);
                        topPear.position.y = 0.7; topPear.parent = mesh;
                        addStem(topPear);
                        break;
                    case "fruit_oval": // Lemon
                        mesh = BABYLON.MeshBuilder.CreateSphere(word, {diameter: 1.4, segments:12}, this.scene);
                        mesh.scaling.y = 1.4; // K√©o d√†i th√†nh h√¨nh b·∫ßu d·ª•c
                        break;
                    case "fruit_cluster": // Grape
                        mesh = new BABYLON.Mesh(word + "_root", this.scene); // Root ·∫£o
                        // T·∫°o ch√πm nho b·∫±ng nhi·ªÅu h√¨nh c·∫ßu nh·ªè
                        const positions = [[0,0,0], [0.4,0.3,0], [-0.4,0.3,0], [0,-0.4,0.3], [0,-0.4,-0.3], [0,0.6,0], [0.3,-0.2,0.3]];
                        positions.forEach(pos => {
                            const g = BABYLON.MeshBuilder.CreateSphere("g", {diameter: 0.7}, this.scene);
                            g.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);
                            g.parent = mesh; g.material = mainMat;
                        });
                        addStem(mesh);
                        break;

                    // --- SHAPES (H√åNH H·ªåC) ---
                    case "shape_disc": // H√¨nh tr√≤n ph·∫≥ng (Circle)
                        mesh = BABYLON.MeshBuilder.CreateCylinder(word, {height: 0.1, diameter: 1.8}, this.scene);
                        mesh.rotation.x = Math.PI/2; // Xoay ƒë·ªÉ ƒë·ªëi di·ªán camera
                        break;
                    case "shape_tile": // H√¨nh vu√¥ng/tam gi√°c ph·∫≥ng
                        // D√πng cylinder v·ªõi s·ªë c·∫°nh (tessellation) t∆∞∆°ng ·ª©ng
                        mesh = BABYLON.MeshBuilder.CreateCylinder(word, {height: 0.1, diameter: 2, tessellation: data.sides}, this.scene);
                        mesh.rotation.x = Math.PI/2;
                        // Xoay th√™m ƒë·ªÉ ƒë√°y ph·∫≥ng n·∫±m ngang n·∫øu l√† tam gi√°c/vu√¥ng
                        mesh.rotation.y = Math.PI / data.sides;
                        break;
                    case "shape_star": // Ng√¥i sao ƒë∆°n gi·∫£n (2 kh·ªëi h·ªôp l·ªìng nhau)
                        mesh = BABYLON.MeshBuilder.CreateBox(word, {size: 1.2}, this.scene);
                        const m2 = mesh.clone("s2"); m2.parent = mesh; m2.rotation.z = Math.PI/4; m2.material = mainMat;
                        // L√†m ph·∫≥ng
                        mesh.scaling.z = 0.1; 
                        break;
                    
                    // --- NUMBERS (S·ªê ƒê·∫æM) ---
                    case "count":
                        mesh = new BABYLON.Mesh(word + "_count_root", this.scene); // Root ·∫£o ch·ª©a c√°c v·∫≠t
                        const qty = data.quantity;
                        const spacing = 0.8;
                        const startX = -(qty - 1) * spacing / 2;
                        for(let i=0; i<qty; i++) {
                            // T·∫°o c√°c qu·∫£ b√≥ng nh·ªè ƒë·ªÉ ƒë·∫øm
                            const unit = BABYLON.MeshBuilder.CreateSphere("u"+i, {diameter: 0.7}, this.scene);
                            unit.position.x = startX + i * spacing;
                            unit.parent = mesh;
                            unit.material = mainMat;
                            // Hi·ªáu ·ª©ng nh·∫•p nh√°y nh·∫π cho sinh ƒë·ªông
                             const bounce = new BABYLON.Animation("b", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                             bounce.setKeys([{frame:0, value:0}, {frame:15 + i*5, value:0.2}, {frame:30 + i*5, value:0}]);
                             unit.animations.push(bounce); this.scene.beginAnimation(unit, 0, 30+i*5, true);
                        }
                        break;

                    // --- OBJECTS ---
                    case "box": mesh = BABYLON.MeshBuilder.CreateBox(word, {size: 1.5}, this.scene); break;
                    case "sphere": mesh = BABYLON.MeshBuilder.CreateSphere(word, {diameter: 1.7}, this.scene); break;
                    case "chair":
                        mesh = BABYLON.MeshBuilder.CreateBox("seat", {width:1.2, depth:1.2, height:0.2}, this.scene);
                        const back = BABYLON.MeshBuilder.CreateBox("back", {width:1.2, depth:0.1, height:1.2}, this.scene);
                        back.parent = mesh; back.position.y = 0.7; back.position.z = 0.55; back.material = mainMat;
                        // Legs
                        [ [-0.5,0.5], [0.5,0.5], [-0.5,-0.5], [0.5,-0.5] ].forEach(p => {
                            const leg = BABYLON.MeshBuilder.CreateCylinder("l",{height:1, diameter:0.15},this.scene);
                            leg.parent = mesh; leg.position.y = -0.6; leg.position.x = p[0]; leg.position.z = p[1]; leg.material = mainMat;
                        });
                        break;
                    case "cup":
                         // T·∫°o c·ªëc b·∫±ng tube (·ªëng r·ªóng) v√† disc (ƒë√°y)
                         mesh = BABYLON.MeshBuilder.CreateTube(word, {path: [new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(0,1.2,0)], radius: 0.6, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, this.scene);
                         const bottom = BABYLON.MeshBuilder.CreateDisc("bot", {radius:0.6}, this.scene);
                         bottom.rotation.x = Math.PI/2; bottom.parent = mesh; bottom.material = mainMat;
                         // Tay c·∫ßm
                         const handle = BABYLON.MeshBuilder.CreateTorus("h", {diameter:0.6, thickness:0.15}, this.scene);
                         handle.parent = mesh; handle.position.x = -0.6; handle.position.y = 0.6; handle.material = mainMat;
                         break;
                    case "spoon":
                        mesh = BABYLON.MeshBuilder.CreateCylinder("handle", {height:1.5, diameter:0.1}, this.scene);
                        const bowl = BABYLON.MeshBuilder.CreateSphere("bowl", {diameter:0.6, slice:0.4}, this.scene);
                        bowl.parent=mesh; bowl.position.y = 0.8; bowl.scaling.z = 0.5; bowl.rotation.x = Math.PI; bowl.material=mainMat;
                        break;
                    case "car":
                        mesh = BABYLON.MeshBuilder.CreateBox("body", {width: 1.6, height: 0.6, depth: 1}, this.scene);
                        const top = BABYLON.MeshBuilder.CreateBox("top", {width: 0.8, height: 0.5, depth: 0.8}, this.scene);
                        top.position.y = 0.5; top.parent = mesh; top.material = mainMat;
                        const wheelMat = new BABYLON.StandardMaterial("blk", this.scene); wheelMat.diffuseColor = BABYLON.Color3.Black();
                        [ [-0.5, 0.6], [0.5, 0.6], [-0.5, -0.6], [0.5, -0.6] ].forEach(pos => {
                            const w = BABYLON.MeshBuilder.CreateCylinder("w", {diameter: 0.5, height: 0.2}, this.scene);
                            w.rotation.x = Math.PI/2; w.position.set(pos[0], -0.3, pos[1]); w.material = wheelMat; w.parent = mesh;
                        });
                        break;
                    case "book":
                         mesh = BABYLON.MeshBuilder.CreateBox(word, {width: 1.2, height: 1.6, depth: 0.3}, this.scene);
                         const pages = BABYLON.MeshBuilder.CreateBox("pages", {width:1.1, height:1.5, depth:0.25}, this.scene);
                         pages.parent = mesh; pages.position.x = 0.05; 
                         pages.material = new BABYLON.StandardMaterial("paper", this.scene); pages.material.diffuseColor = BABYLON.Color3.White();
                         break;

                    default: // Fallback shape
                        mesh = BABYLON.MeshBuilder.CreateBox(word, {size: 1.2}, this.scene);
                        break;
                }

                // G√°n material ch√≠nh n·∫øu ch∆∞a c√≥
                if(mesh && !mesh.material) mesh.material = mainMat;
                
                // Th√™m chuy·ªÉn ƒë·ªông "th·ªü" nh·∫π cho t·∫•t c·∫£ ƒë·ªì v·∫≠t ƒë·ªÉ sinh ƒë·ªông
                if(mesh) {
                    const bobAnim = new BABYLON.Animation("bobIdle", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    const currentY = mesh.position.y;
                    bobAnim.setKeys([{frame:0, value: currentY}, {frame:45, value: currentY + 0.15}, {frame:90, value: currentY}]);
                    mesh.animations.push(bobAnim);
                    this.scene.beginAnimation(mesh, Math.random()*90, 90 + Math.random()*90, true); // B·∫Øt ƒë·∫ßu ng·∫´u nhi√™n ƒë·ªÉ kh√¥ng ƒë·ªìng b·ªô
                }

                return mesh;
            }
        }

        // --- START GAME ---
        const game = new Game();
        // K√≠ch ho·∫°t l·∫°i √¢m thanh tr√™n iOS khi ch·∫°m l·∫ßn ƒë·∫ßu
        window.addEventListener('touchstart', function() { 
            if(audioCtx.state !== 'running') audioCtx.resume(); 
        }, {once:true});

    </script>
</body>
</html>
