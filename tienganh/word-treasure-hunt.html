<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Treasure Hunt</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-land: #E8F5E9;
            --bg-grid: #C8E6C9;
            --ui-font: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            --primary: #4CAF50;
            --accent: #FFC107;
            --danger: #F44336;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            background-color: var(--bg-land);
            font-family: var(--ui-font);
            display: flex; flex-direction: column;
        }

        /* --- UI OVERLAY --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255, 255, 255, 0.95);
            z-index: 20; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        .btn {
            background: var(--primary); color: white; border: none; border-radius: 50px;
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            box-shadow: 0 6px 0 #2E7D32; cursor: pointer; margin: 10px;
            font-family: inherit; transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-home { background: #2196F3; box-shadow: 0 5px 0 #0D47A1; }

        /* --- HUD --- */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 10px; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; gap: 10px;
        }
        
        .top-row {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px; border-radius: 20px;
            font-weight: bold; font-size: 1.1rem; color: #333;
            box-shadow: 0 3px 5px rgba(0,0,0,0.1); pointer-events: auto;
            display: flex; align-items: center; gap: 5px;
        }
        
        .hearts { color: var(--danger); font-size: 1.4rem; letter-spacing: 2px; }

        /* --- TARGET BAR --- */
        #target-bar {
            background: #FFF; padding: 10px 25px; border-radius: 50px;
            display: flex; align-items: center; gap: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 3px solid var(--accent);
            align-self: center; pointer-events: auto;
        }
        #target-word { font-size: 1.8rem; font-weight: 900; color: #E91E63; text-transform: uppercase; }
        .speak-btn {
            background: var(--primary); border: none; border-radius: 50%; width: 40px; height: 40px;
            font-size: 1.2rem; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
        }

        /* --- CONTROLS --- */
        #joystick-zone {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(0,0,0,0.1); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            display: none; /* Shown on touch */
            z-index: 15;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        #hint-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 70px; height: 70px; border-radius: 50%;
            background: var(--accent); border: 4px solid #FFCA28;
            font-size: 2rem; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #FF6F00; cursor: pointer; pointer-events: auto; z-index: 15;
        }
        #hint-btn:active { transform: translateY(4px); box-shadow: none; }
        #hint-count { font-size: 0.9rem; position: absolute; bottom: 15px; font-weight: bold; color: #444; }

        /* --- CANVAS --- */
        canvas { display: block; width: 100%; height: 100%; }

        @media (hover: none) and (pointer: coarse) {
            #joystick-zone { display: block; }
        }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1 style="color: var(--primary); font-size: 3rem; margin-bottom: 10px;">Word Treasure Hunt</h1>
        <div style="font-size: 5rem; margin-bottom: 20px;">üèÉ‚Äç‚ôÇÔ∏èüó∫Ô∏èüíé</div>
        <p>Use Arrows/Joystick to move!</p>
        <button class="btn" onclick="game.start()">START ADVENTURE ‚ñ∂</button>
    </div>

    <div id="hud" class="hidden">
        <div class="top-row">
            <div class="stat-box">
                <button onclick="game.goHome()" style="background:none;border:none;font-size:1.2rem;cursor:pointer;">üè†</button>
                <span>Lv.<span id="hud-level">1</span></span>
            </div>
            <div class="stat-box hearts" id="hearts-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div class="stat-box">Score: <span id="hud-score">0</span></div>
        </div>
        <div id="target-bar">
            <span style="font-weight:bold; color:#555;">Collect: </span>
            <span id="target-word">APPLE</span>
            <button class="speak-btn" onclick="game.speakTarget()">üîä</button>
        </div>
    </div>

    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="hint-btn" class="hidden" onclick="game.useHint()">üí°<span id="hint-count">3</span></div>

    <canvas id="gameCanvas"></canvas>

    <div id="win-screen" class="screen hidden">
        <h1 style="color: var(--primary)">Level Complete! üéâ</h1>
        <div style="font-size: 4rem;">‚≠êüèÜ‚≠ê</div>
        <button class="btn" onclick="game.nextLevel()">Next Level ‚ñ∂</button>
    </div>

    <div id="lose-screen" class="screen hidden">
        <h1 style="color: var(--danger)">Oh No! üò¢</h1>
        <p>Out of hearts!</p>
        <button class="btn" onclick="game.retryLevel()">Try Again ‚Ü∫</button>
        <button class="btn btn-home" onclick="game.goHome()">Home</button>
    </div>

    <script>
        // --- DATA ---
        const LEVEL_DATA = [
            { cat: 'FRUITS', items: [ {w:'APPLE',e:'üçé'}, {w:'BANANA',e:'üçå'}, {w:'GRAPE',e:'üçá'} ], distractors: ['üê∂','üöó','‚öΩ'] },
            { cat: 'ANIMALS', items: [ {w:'DOG',e:'üê∂'}, {w:'CAT',e:'üê±'}, {w:'LION',e:'ü¶Å'} ], distractors: ['üçé','üöó','üå≤'] },
            { cat: 'VEHICLES', items: [ {w:'CAR',e:'üöó'}, {w:'BUS',e:'üöå'}, {w:'PLANE',e:'‚úàÔ∏è'} ], distractors: ['üê±','üçé','üè†'] },
            { cat: 'TOYS', items: [ {w:'BALL',e:'‚öΩ'}, {w:'ROBOT',e:'ü§ñ'}, {w:'DOLL',e:'üéé'}, {w:'KITE',e:'ü™Å'} ], distractors: ['ü¶Å','üçá','üå∏'] },
            { cat: 'NATURE', items: [ {w:'SUN',e:'‚òÄÔ∏è'}, {w:'TREE',e:'üå≥'}, {w:'FLOWER',e:'üå∏'}, {w:'MOON',e:'üåô'} ], distractors: ['üöå','üê∂','‚öΩ'] },
            { cat: 'FOOD', items: [ {w:'PIZZA',e:'üçï'}, {w:'BURGER',e:'üçî'}, {w:'CAKE',e:'üç∞'}, {w:'EGG',e:'üç≥'} ], distractors: ['üöó','üå≤','üê±'] },
            { cat: 'BODY', items: [ {w:'EYE',e:'üëÅÔ∏è'}, {w:'EAR',e:'üëÇ'}, {w:'HAND',e:'‚úã'}, {w:'FOOT',e:'ü¶∂'} ], distractors: ['üçé','‚öΩ','üê∂'] },
            { cat: 'CLOTHES', items: [ {w:'SHIRT',e:'üëï'}, {w:'DRESS',e:'üëó'}, {w:'HAT',e:'üß¢'}, {w:'SHOE',e:'üëü'} ], distractors: ['üçï','üöå','‚òÄÔ∏è'] },
            { cat: 'HOME', items: [ {w:'BED',e:'üõèÔ∏è'}, {w:'TV',e:'üì∫'}, {w:'LAMP',e:'üí°'}, {w:'CLOCK',e:'‚è∞'} ], distractors: ['üå≥','ü¶Å','üçá'] },
            { cat: 'MIXED', items: [ {w:'STAR',e:'‚≠ê'}, {w:'FISH',e:'üêü'}, {w:'BOOK',e:'üìñ'}, {w:'KEY',e:'üîë'}, {w:'BELL',e:'üîî'} ], distractors: ['üçé','üöó','üê∂'] }
        ];

        // --- AUDIO ---
        const AudioSys = {
            ctx: null,
            init: function() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone: function(freq, type, duration) {
                if (!this.ctx) this.init();
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(0.1, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                o.connect(g); g.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime + duration);
            },
            collect: function() { this.playTone(600, 'sine', 0.1); setTimeout(()=>this.playTone(1000, 'sine', 0.1), 100); },
            wrong: function() { this.playTone(150, 'sawtooth', 0.3); },
            speak: function(text) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'en-US'; u.rate = 0.9;
                window.speechSynthesis.speak(u);
            }
        };

        // --- GAME CLASSES ---
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 40;
                this.speed = 5;
                this.vx = 0;
                this.vy = 0;
                this.emoji = "üèÉ";
                this.facingRight = true;
            }

            update(input, w, h) {
                // Normalize speed for diagonal movement
                let moveX = input.x;
                let moveY = input.y;
                const mag = Math.sqrt(moveX*moveX + moveY*moveY);
                if (mag > 1) { moveX /= mag; moveY /= mag; }

                this.vx = moveX * this.speed;
                this.vy = moveY * this.speed;

                this.x += this.vx;
                this.y += this.vy;

                // Bounds
                this.x = Math.max(this.size, Math.min(w - this.size, this.x));
                this.y = Math.max(this.size, Math.min(h - this.size, this.y));

                // Animation direction
                if(this.vx > 0) this.facingRight = true;
                if(this.vx < 0) this.facingRight = false;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                if(!this.facingRight) ctx.scale(-1, 1);
                
                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.beginPath(); ctx.ellipse(0, 15, 15, 5, 0, 0, Math.PI*2); ctx.fill();

                // Character
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }

        class Item {
            constructor(data, x, y, isTarget) {
                this.data = data; // {w, e} or just e string
                this.x = x;
                this.y = y;
                this.size = 30;
                this.isTarget = isTarget;
                this.floatOffset = Math.random() * Math.PI * 2;
                this.collected = false;
            }

            draw(ctx) {
                if(this.collected) return;
                const floatY = Math.sin(Date.now() * 0.003 + this.floatOffset) * 5;
                
                ctx.save();
                ctx.translate(this.x, this.y + floatY);
                
                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.1)";
                ctx.beginPath(); ctx.ellipse(0, 20, 12, 4, 0, 0, Math.PI*2); ctx.fill();

                ctx.font = "35px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                const char = this.data.e || this.data; // Handle object or string distractor
                ctx.fillText(char, 0, 0);
                ctx.restore();
            }
        }

        // --- MAIN ENGINE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.joystickZone = document.getElementById('joystick-zone');
                this.joystickKnob = document.getElementById('joystick-knob');
                
                this.level = 1;
                this.score = 0;
                this.hearts = 3;
                this.hints = 3;
                
                this.player = new Player(0,0);
                this.items = [];
                this.targetItem = null; // The object reference
                this.queue = []; // List of targets for the level
                
                this.input = { x: 0, y: 0 };
                this.isRunning = false;
                this.hintActive = false;
                this.hintTimer = 0;

                this.setupInputs();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupInputs() {
                // Keyboard
                const keys = {};
                window.addEventListener('keydown', e => { keys[e.code] = true; this.updateInput(keys); });
                window.addEventListener('keyup', e => { keys[e.code] = false; this.updateInput(keys); });

                // Joystick
                let startX, startY;
                const radius = 35; // max drag radius

                const handleMove = (e) => {
                    const touch = e.touches[0];
                    const dx = touch.clientX - startX;
                    const dy = touch.clientY - startY;
                    const distance = Math.min(Math.hypot(dx, dy), radius);
                    const angle = Math.atan2(dy, dx);
                    
                    const knobX = Math.cos(angle) * distance;
                    const knobY = Math.sin(angle) * distance;
                    
                    this.joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                    
                    this.input.x = knobX / radius;
                    this.input.y = knobY / radius;
                };

                const handleEnd = () => {
                    this.joystickKnob.style.transform = `translate(-50%, -50%)`;
                    this.input.x = 0;
                    this.input.y = 0;
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('touchend', handleEnd);
                };

                this.joystickZone.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const rect = this.joystickZone.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                    document.addEventListener('touchmove', handleMove, {passive: false});
                    document.addEventListener('touchend', handleEnd);
                }, {passive: false});
            }

            updateInput(keys) {
                this.input.x = (keys['ArrowRight'] || keys['KeyD'] ? 1 : 0) - (keys['ArrowLeft'] || keys['KeyA'] ? 1 : 0);
                this.input.y = (keys['ArrowDown'] || keys['KeyS'] ? 1 : 0) - (keys['ArrowUp'] || keys['KeyW'] ? 1 : 0);
            }

            start() {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                document.getElementById('hint-btn').classList.remove('hidden');
                
                this.resize();
                this.level = 1;
                this.score = 0;
                AudioSys.init();
                this.startLevel();
                
                this.isRunning = true;
                this.loop();
            }

            startLevel() {
                this.hearts = 3;
                this.hints = 3;
                this.hintActive = false;
                this.updateHUD();

                const data = LEVEL_DATA[(this.level - 1) % LEVEL_DATA.length];
                this.queue = [...data.items]; // Copy targets
                
                // Prepare map
                this.items = [];
                const margin = 50;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Player Start
                this.player.x = w / 2;
                this.player.y = h / 2;

                // Create items (Targets + Distractors)
                // 1. Place targets
                this.queue.forEach(t => {
                    this.spawnItem(t, true);
                });
                // 2. Place distractors
                const distCount = 5 + this.level;
                for(let i=0; i<distCount; i++) {
                    const d = data.distractors[i % data.distractors.length];
                    this.spawnItem(d, false);
                }

                this.nextTarget();
            }

            spawnItem(data, isTarget) {
                const margin = 60;
                let x, y, tooClose;
                let attempts = 0;
                do {
                    x = margin + Math.random() * (this.canvas.width - margin * 2);
                    y = margin + Math.random() * (this.canvas.height - margin * 2);
                    tooClose = false;
                    
                    // Check against player
                    if(Math.hypot(x - this.player.x, y - this.player.y) < 150) tooClose = true;
                    // Check against other items
                    for(let item of this.items) {
                        if(Math.hypot(x - item.x, y - item.y) < 60) tooClose = true;
                    }
                    attempts++;
                } while (tooClose && attempts < 100);

                this.items.push(new Item(data, x, y, isTarget));
            }

            nextTarget() {
                if(this.queue.length === 0) {
                    this.completeLevel();
                    return;
                }
                const nextData = this.queue.shift();
                
                // Find this specific item instance in the world
                this.targetItem = this.items.find(i => i.isTarget && i.data.w === nextData.w && !i.collected);
                
                // UI
                document.getElementById('target-word').innerText = nextData.w;
                setTimeout(() => this.speakTarget(), 500);
            }

            speakTarget() {
                const word = document.getElementById('target-word').innerText;
                AudioSys.speak("Find " + word);
            }

            update() {
                this.player.update(this.input, this.canvas.width, this.canvas.height);

                // Collision Detection
                for(let item of this.items) {
                    if(item.collected) continue;
                    
                    const dist = Math.hypot(this.player.x - item.x, this.player.y - item.y);
                    if(dist < (this.player.size + item.size)) {
                        this.handleCollision(item);
                    }
                }

                // Hint timer
                if(this.hintActive) {
                    if(Date.now() > this.hintTimer) this.hintActive = false;
                }
            }

            handleCollision(item) {
                if(item === this.targetItem) {
                    // Correct
                    item.collected = true;
                    this.score += 100;
                    AudioSys.collect();
                    
                    // Confetti at item pos
                    const cx = item.x / this.canvas.width;
                    const cy = item.y / this.canvas.height;
                    confetti({ particleCount: 50, spread: 50, origin: { x: cx, y: cy } });

                    this.updateHUD();
                    this.hintActive = false;
                    this.nextTarget();
                } else {
                    // Wrong
                    if(!item.isTarget) { // Only penalty for distractors or wrong order targets?
                        // Let's penalize for anything that isn't the CURRENT target
                        this.triggerPenalty();
                        // Push player back
                        const angle = Math.atan2(this.player.y - item.y, this.player.x - item.x);
                        this.player.x += Math.cos(angle) * 30;
                        this.player.y += Math.sin(angle) * 30;
                    } else if (item.isTarget && item !== this.targetItem) {
                         // Hit a future target
                         this.triggerPenalty();
                         const angle = Math.atan2(this.player.y - item.y, this.player.x - item.x);
                         this.player.x += Math.cos(angle) * 30;
                         this.player.y += Math.sin(angle) * 30;
                    }
                }
            }

            triggerPenalty() {
                AudioSys.wrong();
                this.hearts--;
                this.updateHUD();
                document.body.style.backgroundColor = "#FFCDD2";
                setTimeout(() => document.body.style.backgroundColor = "var(--bg-land)", 200);
                
                if(this.hearts <= 0) {
                    this.gameOver();
                }
            }

            draw() {
                // Clear
                this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-land');
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Grid lines (optional for depth)
                this.ctx.strokeStyle = "rgba(0,0,0,0.05)";
                this.ctx.lineWidth = 2;
                const gridSize = 100;
                for(let x=0; x<this.canvas.width; x+=gridSize) {
                    this.ctx.beginPath(); this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.canvas.height); this.ctx.stroke();
                }
                for(let y=0; y<this.canvas.height; y+=gridSize) {
                    this.ctx.beginPath(); this.ctx.moveTo(0,y); this.ctx.lineTo(this.canvas.width,y); this.ctx.stroke();
                }

                // Draw Items
                this.items.forEach(i => i.draw(this.ctx));

                // Draw Hint Arrow
                if(this.hintActive && this.targetItem) {
                    this.drawArrow(this.player.x, this.player.y, this.targetItem.x, this.targetItem.y);
                }

                // Draw Player
                this.player.draw(this.ctx);
            }

            drawArrow(x1, y1, x2, y2) {
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const dist = 70; // Distance from player
                const ax = x1 + Math.cos(angle) * dist;
                const ay = y1 + Math.sin(angle) * dist;

                this.ctx.save();
                this.ctx.translate(ax, ay);
                this.ctx.rotate(angle);
                this.ctx.fillStyle = "rgba(255, 193, 7, 0.7)";
                this.ctx.beginPath();
                this.ctx.moveTo(10, 0);
                this.ctx.lineTo(-10, 10);
                this.ctx.lineTo(-10, -10);
                this.ctx.fill();
                this.ctx.restore();
            }

            loop() {
                if(!this.isRunning) return;
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }

            useHint() {
                if(this.hints > 0 && this.targetItem) {
                    this.hints--;
                    this.hintActive = true;
                    this.hintTimer = Date.now() + 2000; // 2 seconds
                    this.updateHUD();
                }
            }

            updateHUD() {
                document.getElementById('hud-level').innerText = this.level;
                document.getElementById('hud-score').innerText = this.score;
                let h = ""; for(let i=0; i<3; i++) h += i<this.hearts ? "‚ù§Ô∏è" : "üñ§";
                document.getElementById('hearts-display').innerText = h;
                
                const hb = document.getElementById('hint-btn');
                document.getElementById('hint-count').innerText = this.hints;
                hb.style.opacity = this.hints > 0 ? 1 : 0.5;
            }

            completeLevel() {
                this.isRunning = false;
                document.getElementById('win-screen').classList.remove('hidden');
                confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 } });
            }

            gameOver() {
                this.isRunning = false;
                document.getElementById('lose-screen').classList.remove('hidden');
            }

            nextLevel() {
                this.level++;
                document.getElementById('win-screen').classList.add('hidden');
                this.startLevel();
                this.isRunning = true;
                this.loop();
            }

            retryLevel() {
                document.getElementById('lose-screen').classList.add('hidden');
                this.startLevel();
                this.isRunning = true;
                this.loop();
            }

            goHome() {
                this.isRunning = false;
                document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
                document.getElementById('hud').classList.add('hidden');
                document.getElementById('hint-btn').classList.add('hidden');
                document.getElementById('start-screen').classList.remove('hidden');
            }
        }

        const game = new Game();
    </script>
</body>
</html>
