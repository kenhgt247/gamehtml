<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#4CAF50">
<title>Magic Garden Grow</title>
<style>
    :root {
        --safe-top: env(safe-area-inset-top, 20px);
        --safe-bottom: env(safe-area-inset-bottom, 20px);
        --primary: #4CAF50;
        --accent: #FFEB3B;
        --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: none; user-select: none; }
    
    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background: #E8F5E9; font-family: var(--font); overflow: hidden;
    }

    #game-container {
        position: relative; width: 100%; height: 100%;
        display: flex; flex-direction: column;
    }

    canvas { display: block; width: 100%; height: 100%; }

    /* UI OVERLAYS */
    .screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: rgba(255,255,255,0.9); z-index: 10;
        transition: opacity 0.3s; padding: 20px; text-align: center;
    }
    .hidden { opacity: 0; pointer-events: none; }
    
    h1 { font-size: 3rem; color: var(--primary); margin: 0 0 20px; text-shadow: 2px 2px 0px #A5D6A7; }
    p { font-size: 1.5rem; color: #555; margin-bottom: 30px; }

    button {
        background: linear-gradient(to bottom, #66BB6A, #43A047);
        border: none; border-bottom: 6px solid #2E7D32;
        color: white; font-size: 1.8rem; font-weight: bold;
        padding: 15px 40px; border-radius: 50px;
        cursor: pointer; box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        transition: transform 0.1s, border-bottom 0.1s;
    }
    button:active { transform: translateY(4px); border-bottom: 2px solid #2E7D32; }

    /* HUD */
    #hud {
        position: absolute; top: 0; left: 0; width: 100%;
        padding: var(--safe-top) 20px 0 20px;
        display: flex; justify-content: space-between; align-items: center;
        pointer-events: none; z-index: 5;
    }
    .hud-btn {
        pointer-events: auto; background: white; border-radius: 50%;
        width: 50px; height: 50px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        display: flex; justify-content: center; align-items: center;
        font-size: 1.5rem; border: 2px solid #eee; margin-top: 10px;
    }
    .bar-container {
        flex-grow: 1; margin: 10px 20px 0; height: 20px;
        background: rgba(0,0,0,0.1); border-radius: 10px; overflow: hidden;
    }
    #progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.5s; }
    
    #tutorial-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6); z-index: 8; display: none;
        justify-content: center; align-items: center; color: white;
        font-size: 2rem; font-weight: bold; text-align: center; pointer-events: none;
    }
    
    .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-4px, 0, 0); } 20%, 80% { transform: translate3d(8px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-8px, 0, 0); } 40%, 60% { transform: translate3d(8px, 0, 0); } }

</style>
</head>
<body>

<div id="game-container">
    <canvas id="cvs"></canvas>

    <div id="hud" class="hidden">
        <button id="btn-pause" class="hud-btn">‚è∏</button>
        <div class="bar-container"><div id="progress-fill"></div></div>
        <div style="display:flex; gap:10px">
            <button id="btn-hint" class="hud-btn" style="background:#FFF9C4">üí°</button>
            <div id="level-display" class="hud-btn" style="border-radius:15px; width:auto; padding:0 15px; font-weight:bold; font-size:1.2rem; color:#4CAF50">1</div>
        </div>
    </div>

    <div id="tutorial-overlay">
        <div id="tut-hand">üëÜ <span id="tut-text">Tap the Water!</span></div>
    </div>

    <div id="screen-start" class="screen">
        <h1>Magic Garden üåª</h1>
        <p>Help the plants grow!</p>
        <button id="btn-start">PLAY</button>
    </div>

    <div id="screen-pause" class="screen hidden">
        <h1>Paused</h1>
        <button id="btn-resume">RESUME</button>
    </div>

    <div id="screen-win" class="screen hidden">
        <h1 style="color:#FFC107">Great Job! üåü</h1>
        <p id="praise-text">Amazing!</p>
        <button id="btn-next">NEXT LEVEL</button>
    </div>

    <div id="screen-end" class="screen hidden">
        <h1>YOU WON! üèÜ</h1>
        <p>You are a Master Gardener!</p>
        <button id="btn-restart">PLAY AGAIN</button>
    </div>
</div>

<script>
/**
 * SENIOR ENGINEER NOTE:
 * Architecture:
 * 1. AudioController: Handles iOS unlock quirks, SpeechSynthesis with en-GB priority, and Oscillator SFX.
 * 2. GameEngine: Main loop, state machine (MENU, PLAY, PAUSE, WIN), collision logic.
 * 3. Renderer: Pure Canvas API drawing (Procedural Graphics).
 * 4. LevelSystem: Procedural generation of 30 levels with ramping difficulty.
 */

// --- CONFIGURATION ---
const CFG = {
    colors: { bg: '#E8F5E9', ground: '#8D6E63', sky: '#B3E5FC' },
    tools: [
        { id: 'water', color: '#29B6F6', label: 'Water' },
        { id: 'sun',   color: '#FFEB3B', label: 'Sun' },
        { id: 'food',  color: '#795548', label: 'Food' }, // Fertilizer
        { id: 'love',  color: '#E91E63', label: 'Love' }  // Heart/Prune
    ],
    totalLevels: 30,
    hintCooldown: 3000
};

// --- AUDIO SYSTEM (iOS OPTIMIZED) ---
class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.voices = [];
        this.voice = null;
        this.unlocked = false;
        
        // Load Voices
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = () => this.loadVoices();
            this.loadVoices();
        }
    }

    loadVoices() {
        const all = window.speechSynthesis.getVoices();
        // Priority: en-GB -> en-US -> en-*
        this.voice = all.find(v => v.lang === 'en-GB') || 
                     all.find(v => v.lang === 'en-US') || 
                     all.find(v => v.lang.indexOf('en') > -1);
    }

    unlock() {
        if (this.unlocked) return;
        // iOS Unlock Pattern: Resume context + play silent buffer inside a touch event
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const buffer = this.ctx.createBuffer(1, 1, 22050);
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(this.ctx.destination);
        source.start(0);
        this.unlocked = true;
    }

    playTone(type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        const now = this.ctx.currentTime;
        if (type === 'success') {
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'error') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(100, now + 0.2);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'pop') {
            osc.frequency.setValueAtTime(600, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        }
    }

    speak(text) {
        if (!('speechSynthesis' in window)) return;
        // iOS Bug Fix: Cancel before speaking and add tiny delay
        window.speechSynthesis.cancel();
        setTimeout(() => {
            const u = new SpeechSynthesisUtterance(text);
            if (this.voice) u.voice = this.voice;
            u.rate = 0.9; // Slightly slower for kids
            u.pitch = 1.1; // Friendly pitch
            u.volume = 1.0;
            window.speechSynthesis.speak(u);
        }, 60);
    }
}

// --- GAME LOGIC ---
class Game {
    constructor() {
        this.cvs = document.getElementById('cvs');
        this.ctx = this.cvs.getContext('2d');
        this.audio = new AudioController();
        
        this.state = 'START'; // START, PLAY, PAUSE, WIN_LEVEL, END
        this.level = 1;
        this.score = 0;
        this.streak = 0;
        this.hints = 3;
        
        this.plant = { stage: 0, scale: 0.5 };
        this.targetTool = null;
        this.activeTools = []; // Tools displayed on screen
        this.particles = [];
        this.lastError = 0;

        // Bounding boxes for clicks
        this.toolBounds = []; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Inputs
        this.cvs.addEventListener('pointerdown', (e) => this.handleInput(e));
        
        // UI Bindings
        document.getElementById('btn-start').onclick = () => this.startGame();
        document.getElementById('btn-pause').onclick = () => this.togglePause();
        document.getElementById('btn-resume').onclick = () => this.togglePause();
        document.getElementById('btn-next').onclick = () => this.nextLevel();
        document.getElementById('btn-restart').onclick = () => this.resetGame();
        document.getElementById('btn-hint').onclick = () => this.useHint();

        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.cvs.width = this.width * window.devicePixelRatio;
        this.cvs.height = this.height * window.devicePixelRatio;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    startGame() {
        this.audio.unlock(); // Vital for iOS
        this.level = 1;
        this.hints = 3;
        this.loadLevel();
        this.setUI('hud');
        this.audio.speak("Let's grow a garden!");
    }

    resetGame() {
        this.level = 1;
        this.loadLevel();
        this.setUI('hud');
    }

    loadLevel() {
        this.state = 'PLAY';
        this.plant = { stage: 0, scale: 0.5, targetStage: 3 };
        this.streak = 0;
        this.particles = [];
        this.toolBounds = [];
        this.hintActive = false;
        
        // Level Generation Logic
        // 1-5: 2 tools. 6-15: 3 tools. 16+: 4 tools.
        let numTools = 2;
        if (this.level > 5) numTools = 3;
        if (this.level > 15) numTools = 4;

        // Pick tools
        const available = CFG.tools.slice(0, numTools);
        this.activeTools = available;

        // Pick a requirement
        this.nextRequirement();

        // Update UI
        document.getElementById('level-display').innerText = "Level " + this.level;
        document.getElementById('progress-fill').style.width = ((this.level-1) / CFG.totalLevels * 100) + '%';
        
        // Tutorial
        const tut = document.getElementById('tutorial-overlay');
        if (this.level <= 2) {
            tut.style.display = 'flex';
            document.getElementById('tut-text').innerText = "Tap the " + this.targetTool.label + "!";
        } else {
            tut.style.display = 'none';
        }
    }

    nextRequirement() {
        // Pick random tool from active set
        this.targetTool = this.activeTools[Math.floor(Math.random() * this.activeTools.length)];
        
        // Speak instructions
        const phrases = [
            `The plant needs ${this.targetTool.label}`,
            `Please give it ${this.targetTool.label}`,
            `It wants ${this.targetTool.label}`
        ];
        // Don't speak immediately if rapid firing, handled by queue in AudioController
        if (this.state === 'PLAY') {
            this.audio.speak(phrases[Math.floor(Math.random()*phrases.length)]);
        }
    }

    handleInput(e) {
        if (this.state !== 'PLAY') return;

        const rect = this.cvs.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Tutorial dismissal
        if (this.level <= 2 && document.getElementById('tutorial-overlay').style.display !== 'none') {
            document.getElementById('tutorial-overlay').style.display = 'none';
        }

        // Check Tools
        for (let b of this.toolBounds) {
            if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                this.checkAction(b.id, b.x + b.w/2, b.y + b.h/2);
            }
        }
    }

    checkAction(toolId, x, y) {
        if (Date.now() - this.lastError < 500) return; // Cooldown

        if (toolId === this.targetTool.id) {
            // Success
            this.audio.playTone('success');
            this.spawnParticles(x, y, CFG.tools.find(t=>t.id===toolId).color);
            this.plant.scale += 0.2;
            this.plant.stage++;
            this.streak++;
            this.hintActive = false;

            if (this.plant.stage >= this.plant.targetStage) {
                this.winLevel();
            } else {
                this.nextRequirement();
            }
        } else {
            // Fail
            this.audio.playTone('error');
            this.streak = 0;
            this.lastError = Date.now();
            this.cvs.classList.add('shake');
            this.audio.speak("Oops, try again!");
            setTimeout(() => this.cvs.classList.remove('shake'), 500);
        }
    }

    useHint() {
        if (this.hints > 0 && this.state === 'PLAY' && !this.hintActive) {
            this.hints--;
            this.hintActive = true;
            this.audio.playTone('pop');
            // Visual hint handled in draw loop
        }
    }

    winLevel() {
        this.state = 'WIN_LEVEL';
        this.audio.playTone('success');
        
        const praise = ["Amazing!", "Great Job!", "Fantastic!", "Super!", "You did it!"];
        const text = praise[Math.floor(Math.random() * praise.length)];
        
        document.getElementById('praise-text').innerText = text;
        this.audio.speak(text);

        // Burst confetti
        for(let i=0; i<50; i++) {
            this.spawnParticles(this.width/2, this.height/2, '#' + Math.floor(Math.random()*16777215).toString(16));
        }

        setTimeout(() => {
            if (this.level >= CFG.totalLevels) {
                this.setUI('screen-end');
                this.audio.speak("Congratulations! You finished the game!");
            } else {
                this.setUI('screen-win');
            }
        }, 1500);
    }

    nextLevel() {
        this.level++;
        this.loadLevel();
        this.setUI('hud');
    }

    togglePause() {
        if (this.state === 'PLAY') {
            this.state = 'PAUSE';
            this.setUI('screen-pause');
        } else if (this.state === 'PAUSE') {
            this.state = 'PLAY';
            this.setUI('hud');
        }
    }

    setUI(activeId) {
        document.querySelectorAll('.screen, #hud').forEach(el => el.classList.add('hidden'));
        const el = document.getElementById(activeId);
        if (el) el.classList.remove('hidden');
    }

    spawnParticles(x, y, color) {
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    // --- RENDERER ---
    loop(t) {
        this.update(t);
        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }

    update(t) {
        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }

    draw() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;

        ctx.clearRect(0, 0, w, h);

        // Draw Sky
        ctx.fillStyle = CFG.colors.sky;
        ctx.fillRect(0, 0, w, h);

        // Draw Ground
        ctx.fillStyle = CFG.colors.ground;
        ctx.beginPath();
        ctx.ellipse(w/2, h, w, h/3, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.state === 'PLAY' || this.state === 'WIN_LEVEL') {
            this.drawPlant(ctx, w/2, h * 0.75);
            this.drawTools(ctx);
            this.drawNeedBubble(ctx, w/2, h * 0.4);
        }

        // Draw Particles
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });
    }

    drawPlant(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        const s = this.plant.scale;
        
        // Stem
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 10 * s;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(10 * s, -50 * s, 0, -100 * s);
        ctx.stroke();

        // Leaves
        if (this.plant.scale > 0.6) {
            ctx.fillStyle = '#66BB6A';
            ctx.beginPath();
            ctx.ellipse(20*s, -40*s, 20*s, 10*s, -0.5, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-20*s, -60*s, 20*s, 10*s, 0.5, 0, Math.PI*2);
            ctx.fill();
        }

        // Flower
        if (this.plant.scale > 0.8) {
            ctx.translate(0, -100 * s);
            // Petals
            const petalColor = '#E91E63'; 
            for (let i = 0; i < 6; i++) {
                ctx.rotate(Math.PI / 3);
                ctx.fillStyle = petalColor;
                ctx.beginPath();
                ctx.ellipse(0, -20 * s, 10 * s, 20 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            // Center
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(0, 0, 15 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }

    drawTools(ctx) {
        this.toolBounds = [];
        const count = this.activeTools.length;
        const boxW = Math.min(100, this.width / (count + 0.5));
        const spacing = (this.width - (boxW * count)) / (count + 1);
        const y = this.height - boxW - Math.max(20, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom') || 20));

        this.activeTools.forEach((tool, i) => {
            const x = spacing + (i * (boxW + spacing));
            
            // Check Hint
            const isHint = this.hintActive && tool.id === this.targetTool.id;
            
            // Draw Box
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.fillStyle = 'white';
            
            // Pulse animation if hint
            let scale = 1;
            if (isHint) {
                scale = 1 + Math.sin(Date.now() / 100) * 0.1;
                ctx.shadowColor = '#FFEB3B';
                ctx.shadowBlur = 20;
            }

            // Draw Background
            ctx.beginPath();
            ctx.arc(x + boxW/2, y + boxW/2, (boxW/2) * scale, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Icon (Procedural)
            const cx = x + boxW/2;
            const cy = y + boxW/2;
            const size = boxW * 0.6 * scale;

            this.drawIcon(ctx, tool.id, cx, cy, size);

            // Save Bounds
            this.toolBounds.push({ id: tool.id, x: x, y: y, w: boxW, h: boxW });
        });
    }

    drawIcon(ctx, id, x, y, s) {
        ctx.save();
        ctx.translate(x, y);
        if (id === 'water') {
            ctx.fillStyle = '#29B6F6';
            ctx.beginPath();
            ctx.moveTo(s/2, -s/2); 
            ctx.arc(0, 0, s/3, 0, Math.PI*2);
            ctx.fill();
            // Spout
            ctx.strokeStyle = '#29B6F6';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(s/4, -s/4); ctx.lineTo(s/2, -s/2); ctx.stroke();
        } else if (id === 'sun') {
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath(); ctx.arc(0,0,s/3,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#FBC02D'; ctx.lineWidth = 3;
            for(let i=0; i<8; i++) {
                ctx.rotate(Math.PI/4);
                ctx.beginPath(); ctx.moveTo(s/3,0); ctx.lineTo(s/2,0); ctx.stroke();
            }
        } else if (id === 'food') {
            ctx.fillStyle = '#795548'; // Bag
            ctx.fillRect(-s/3, -s/3, s/1.5, s/1.5);
            ctx.fillStyle = '#8D6E63';
            ctx.beginPath(); ctx.arc(0,0, s/6, 0, Math.PI*2); ctx.fill();
        } else if (id === 'love') {
            ctx.fillStyle = '#E91E63';
            ctx.beginPath();
            ctx.moveTo(0, s/4);
            ctx.bezierCurveTo(s/2, -s/4, s/2, -s/2, 0, -s/2);
            ctx.bezierCurveTo(-s/2, -s/2, -s/2, -s/4, 0, s/4);
            ctx.fill();
        }
        ctx.restore();
    }

    drawNeedBubble(ctx, x, y) {
        if (!this.targetTool || this.state !== 'PLAY') return;

        const yOffset = Math.sin(Date.now() / 300) * 10;
        
        ctx.save();
        ctx.translate(x, y + yOffset);
        
        // Bubble
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 40, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // Tail
        ctx.beginPath();
        ctx.moveTo(0, 40);
        ctx.lineTo(-10, 55);
        ctx.lineTo(10, 50);
        ctx.fill();
        ctx.stroke();

        // Icon inside
        this.drawIcon(ctx, this.targetTool.id, 0, 0, 50);

        ctx.restore();
    }
}

// Start
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
