<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Color Racing V2</title>
<style>
    :root {
        --primary: #FFD700;
        --accent: #FF4500;
        --bg: #2c3e50;
        --ui-bg: rgba(255, 255, 255, 0.95);
        --font-main: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: none; user-select: none; -webkit-user-select: none; }

    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background-color: var(--bg);
        overflow: hidden;
        font-family: var(--font-main);
    }

    /* CONTAINER */
    #game-container {
        position: relative; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
    }

    canvas {
        background: #34495e;
        width: 100%; height: 100%; display: block;
    }

    /* UI LAYERS */
    .ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 10; pointer-events: none; /* Let clicks pass through empty areas */
    }
    
    .ui-content {
        pointer-events: auto; /* Re-enable clicks for the box */
        background: var(--ui-bg);
        padding: 30px; border-radius: 25px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        max-width: 90%; width: 320px;
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    h1 { margin: 0 0 15px; color: var(--accent); font-size: 2rem; }
    p { font-size: 1.1rem; color: #444; margin-bottom: 25px; line-height: 1.4; }
    
    .btn {
        background: linear-gradient(to bottom, #4CAF50, #2E7D32);
        color: white; border: none; padding: 18px 40px;
        font-size: 1.3rem; border-radius: 50px;
        cursor: pointer; font-weight: bold;
        box-shadow: 0 6px 0 #1B5E20;
        transition: transform 0.1s;
        display: inline-block;
        min-width: 200px;
    }
    .btn:active { transform: translateY(6px); box-shadow: none; }
    .btn.secondary { background: linear-gradient(to bottom, #2196F3, #1565C0); box-shadow: 0 6px 0 #0D47A1; }

    /* HUD */
    #hud {
        position: absolute; top: 0; left: 0; width: 100%;
        padding: max(10px, env(safe-area-inset-top)) 15px 0 15px;
        display: flex; justify-content: space-between; align-items: center;
        z-index: 5; pointer-events: none;
    }
    .hud-item { pointer-events: auto; background: rgba(255,255,255,0.9); padding: 8px 15px; border-radius: 20px; font-weight: bold; font-size: 1.1rem; display: flex; align-items: center; gap: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .btn-icon { width: 45px; height: 45px; border-radius: 50%; border: none; background: white; font-size: 1.4rem; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; display: flex; justify-content: center; align-items: center; pointer-events: auto; }

    /* CONTROLS */
    #action-zone {
        position: absolute; bottom: 40px; right: 30px;
        display: flex; gap: 20px; z-index: 5; pointer-events: none;
    }
    #action-zone .btn-icon { pointer-events: auto; }

    /* UTILS */
    .hidden { display: none !important; }
    .shake { animation: shake 0.5s; }
    @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="hud" class="hidden">
        <div style="display:flex; gap:12px;">
            <button id="btnPause" class="btn-icon">‚è∏</button>
            <button id="btnMute" class="btn-icon">üîä</button>
        </div>
        <div class="hud-item">Level <span id="lblLevel">1</span></div>
        <div class="hud-item" style="color:#e74c3c">‚ù§ <span id="lblHearts">3</span></div>
    </div>

    <div id="action-zone" class="hidden">
        <button id="btnHint" class="btn-icon" style="background:#FFF176;">üí°</button>
        <button id="btnReplayTTS" class="btn-icon" style="background:#81D4FA;">üó£</button>
    </div>

    <div id="screen-start" class="ui-layer">
        <div class="ui-content">
            <h1>Color Racing</h1>
            <p>Drive to the correct color!<br>Avoid wrong colors.</p>
            <button id="btnStart" class="btn">PLAY GAME</button>
        </div>
    </div>

    <div id="screen-pause" class="ui-layer hidden">
        <div class="ui-content">
            <h1>PAUSED</h1>
            <button id="btnResume" class="btn">RESUME</button>
            <div style="height:20px"></div>
            <button id="btnQuit" class="btn secondary">EXIT</button>
        </div>
    </div>

    <div id="screen-gameover" class="ui-layer hidden">
        <div class="ui-content">
            <h1 id="msgGameOver">Game Over</h1>
            <p id="subMsgGameOver">Don't give up!</p>
            <button id="btnRestart" class="btn">PLAY AGAIN</button>
        </div>
    </div>
</div>

<script>
/**
 * V2 FIXED VERSION - Senior HTML5 Engineer
 * Fixes: AudioContext blocking, Spawn loop freeze, Touch handling
 */

const COLORS = [
    { name: "RED", hex: "#FF5252" },
    { name: "BLUE", hex: "#448AFF" },
    { name: "GREEN", hex: "#69F0AE" },
    { name: "YELLOW", hex: "#FFFF00" },
    { name: "PURPLE", hex: "#E040FB" },
    { name: "ORANGE", hex: "#FFAB40" }
];

const CFG = {
    totalLevels: 30,
    baseSpeed: 4,
    maxHearts: 3,
    hitCooldown: 800,
    hintDuration: 2500,
    hintsPerLevel: 3
};

// ==============================
// AUDIO SYSTEM (SAFE MODE)
// ==============================
class AudioSys {
    constructor() {
        this.ctx = null;
        this.isMuted = false;
        this.voice = null;
        
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = () => this.loadVoices();
            this.loadVoices();
        }
    }

    loadVoices() {
        const all = window.speechSynthesis.getVoices();
        this.voice = all.find(v => v.lang === 'en-GB') || 
                     all.find(v => v.lang === 'en-US') || 
                     all.find(v => v.lang.startsWith('en'));
    }

    init() {
        // Wrapped in Try-Catch to prevent Game Crash if Audio Fails
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                this.ctx = new AudioContext();
                // Silent resume
                this.ctx.resume().catch(e => console.log("Audio resume skipped"));
            }
        } catch (e) {
            console.warn("Audio init failed, game continues silent", e);
        }
    }

    toggleMute() {
        this.isMuted = !this.isMuted;
        if (this.isMuted && window.speechSynthesis) window.speechSynthesis.cancel();
        return this.isMuted;
    }

    beep(type) {
        if (this.isMuted || !this.ctx || this.ctx.state !== 'running') return;
        
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);

            const now = this.ctx.currentTime;
            if (type === 'win') {
                osc.frequency.setValueAtTime(500, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'lose') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else {
                // UI Click
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        } catch(e) { /* Ignore audio errors during play */ }
    }

    speak(text) {
        if (this.isMuted || !('speechSynthesis' in window)) return;
        window.speechSynthesis.cancel(); // Clear queue
        
        setTimeout(() => {
            const u = new SpeechSynthesisUtterance(text);
            if (this.voice) u.voice = this.voice;
            u.lang = 'en-GB';
            u.rate = 0.9;
            u.volume = 1.0;
            window.speechSynthesis.speak(u);
        }, 50);
    }
}

// ==============================
// INPUT SYSTEM
// ==============================
class InputHandler {
    constructor(canvas) {
        this.keys = {};
        this.stick = { x: 0, y: 0, active: false };
        this.origin = { x: 0, y: 0 };
        this.radius = 60;
        this.touchId = null;

        // PC
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);

        // Mobile
        canvas.addEventListener('touchstart', e => this.handleStart(e), { passive: false });
        canvas.addEventListener('touchmove', e => this.handleMove(e), { passive: false });
        canvas.addEventListener('touchend', e => this.handleEnd(e), { passive: false });
    }

    handleStart(e) {
        e.preventDefault();
        // Allow restarting touch if one is already active but a new one is better
        if (!this.stick.active) {
            const t = e.changedTouches[0];
            this.touchId = t.identifier;
            this.origin = { x: t.clientX, y: t.clientY };
            this.stick = { x: 0, y: 0, active: true };
        }
    }

    handleMove(e) {
        e.preventDefault();
        if (!this.stick.active) return;

        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                const t = e.changedTouches[i];
                let dx = t.clientX - this.origin.x;
                let dy = t.clientY - this.origin.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > this.radius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * this.radius;
                    dy = Math.sin(angle) * this.radius;
                }
                
                this.stick.x = dx / this.radius;
                this.stick.y = dy / this.radius;
                break;
            }
        }
    }

    handleEnd(e) {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                this.stick.active = false;
                this.stick.x = 0; 
                this.stick.y = 0;
                break;
            }
        }
    }

    getVector() {
        let x = 0, y = 0;
        if (this.keys['ArrowUp'] || this.keys['KeyW']) y -= 1;
        if (this.keys['ArrowDown'] || this.keys['KeyS']) y += 1;
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) x -= 1;
        if (this.keys['ArrowRight'] || this.keys['KeyD']) x += 1;

        if (this.stick.active) {
            x = this.stick.x;
            y = this.stick.y;
        }

        const len = Math.hypot(x, y);
        if (len > 1) { x /= len; y /= len; }
        return { x, y };
    }
}

// ==============================
// GAME LOGIC
// ==============================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new AudioSys();
        this.input = new InputHandler(this.canvas);
        
        this.state = 'MENU';
        this.level = 1;
        this.hearts = CFG.maxHearts;
        this.targets = [];
        this.particles = [];
        this.player = { x: 0, y: 0, size: 40, angle: 0 };
        this.goalColor = null;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
        
        this.bindEvents();
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }

    bindEvents() {
        const get = (id) => document.getElementById(id);
        const hide = (id) => get(id).classList.add('hidden');
        const show = (id) => get(id).classList.remove('hidden');

        // START BUTTON
        get('btnStart').onclick = () => {
            // 1. Init Audio first
            this.audio.init();
            
            // 2. Hide UI immediately
            hide('screen-start');
            show('hud');
            show('action-zone');
            
            // 3. Start Game Logic
            this.startLevel(1);
        };

        get('btnPause').onclick = () => {
            if (this.state === 'PLAYING') {
                this.state = 'PAUSED';
                show('screen-pause');
                this.audio.beep('ui');
            }
        };

        get('btnResume').onclick = () => {
            hide('screen-pause');
            this.state = 'PLAYING';
            this.lastTime = performance.now();
        };

        get('btnQuit').onclick = () => location.reload();

        get('btnRestart').onclick = () => {
            hide('screen-gameover');
            this.startLevel(1);
        };

        get('btnMute').onclick = () => {
            const m = this.audio.toggleMute();
            get('btnMute').textContent = m ? 'üîá' : 'üîä';
            get('btnMute').style.opacity = m ? '0.5' : '1';
        };

        get('btnHint').onclick = () => {
            if(this.state !== 'PLAYING' || this.hintsLeft <= 0) return;
            this.hintsLeft--;
            this.hintEndTime = Date.now() + CFG.hintDuration;
            get('btnHint').style.opacity = this.hintsLeft > 0 ? '1' : '0.3';
            this.audio.beep('ui');
        };

        get('btnReplayTTS').onclick = () => {
            if(this.goalColor) this.audio.speak("Find " + this.goalColor.name);
        };
    }

    startLevel(lvl) {
        this.level = lvl;
        this.state = 'PLAYING';
        this.hearts = this.level === 1 ? CFG.maxHearts : this.hearts; // Keep hearts unless restart
        this.hintsLeft = CFG.hintsPerLevel;
        this.lastHitTime = 0;

        document.getElementById('lblLevel').textContent = this.level;
        document.getElementById('lblHearts').textContent = this.hearts;
        document.getElementById('btnHint').style.opacity = '1';

        // Reset Player
        this.player.x = this.width / 2;
        this.player.y = this.height / 2;
        this.player.angle = 0;
        
        this.targets = [];
        this.particles = [];

        // Logic Difficulty
        const numTargets = Math.min(4 + Math.floor(this.level/2), 12);
        const palette = COLORS.slice(0, Math.min(3 + Math.floor(this.level/4), COLORS.length));
        this.goalColor = palette[Math.floor(Math.random() * palette.length)];

        // Spawn Goal (Guaranteed)
        this.spawnItem(this.goalColor);

        // Spawn Distractors
        for(let i=1; i<numTargets; i++) {
            const randColor = palette[Math.floor(Math.random() * palette.length)];
            this.spawnItem(randColor);
        }

        setTimeout(() => this.audio.speak("Find " + this.goalColor.name), 400);
    }

    spawnItem(color) {
        let x, y, dist, safe;
        let attempts = 0;
        // ANTI-FREEZE PROTECTION
        do {
            safe = true;
            x = Math.random() * (this.width - 100) + 50;
            y = Math.random() * (this.height - 100) + 50;
            
            // Too close to player?
            if (Math.hypot(x - this.player.x, y - this.player.y) < 150) safe = false;
            
            // Too close to other targets?
            for (let t of this.targets) {
                if (Math.hypot(x - t.x, y - t.y) < 80) safe = false;
            }
            attempts++;
        } while(!safe && attempts < 50); // Give up after 50 tries to prevent hang

        if (attempts < 50) {
            this.targets.push({ x, y, color, radius: 35, pulse: Math.random() });
        }
    }

    checkCollision() {
        const now = Date.now();
        if (now - this.lastHitTime < CFG.hitCooldown) return;

        for (let t of this.targets) {
            const dist = Math.hypot(this.player.x - t.x, this.player.y - t.y);
            if (dist < (20 + t.radius)) { // 20 is approx player radius
                this.lastHitTime = now;
                if (t.color.name === this.goalColor.name) {
                    this.doWin();
                } else {
                    this.doFail();
                }
                break;
            }
        }
    }

    doWin() {
        this.state = 'WIN';
        this.audio.beep('win');
        this.audio.speak("Good job!");
        
        // Explosion
        for(let i=0; i<30; i++) {
            this.particles.push({
                x: this.player.x, y: this.player.y,
                vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                life: 1, color: this.goalColor.hex
            });
        }

        setTimeout(() => {
            if (this.level >= CFG.totalLevels) {
                this.gameOver(true);
            } else {
                this.startLevel(this.level + 1);
            }
        }, 1500);
    }

    doFail() {
        this.hearts--;
        document.getElementById('lblHearts').textContent = this.hearts;
        this.audio.beep('lose');
        
        document.body.classList.add('shake');
        setTimeout(()=>document.body.classList.remove('shake'), 500);

        if(this.hearts <= 0) {
            this.gameOver(false);
        } else {
            this.audio.speak("Try again");
        }
    }

    gameOver(win) {
        this.state = 'OVER';
        document.getElementById('screen-gameover').classList.remove('hidden');
        const h1 = document.getElementById('msgGameOver');
        const p = document.getElementById('subMsgGameOver');
        
        if (win) {
            h1.textContent = "YOU WON!"; h1.style.color = "gold";
            p.textContent = "Mission Completed!";
            this.audio.speak("Congratulations!");
        } else {
            h1.textContent = "GAME OVER"; h1.style.color = "red";
            p.textContent = "Good effort!";
            this.audio.speak("Game Over");
        }
    }

    update(dt) {
        if (this.state !== 'PLAYING' && this.state !== 'WIN') return;

        // Player Move
        const vec = this.input.getVector();
        if (vec.x !== 0 || vec.y !== 0) {
            const spd = CFG.baseSpeed * 60 * dt;
            this.player.x += vec.x * spd;
            this.player.y += vec.y * spd;
            this.player.angle = Math.atan2(vec.y, vec.x);
        }
        
        // Bounds
        this.player.x = Math.max(30, Math.min(this.width - 30, this.player.x));
        this.player.y = Math.max(30, Math.min(this.height - 30, this.player.y));

        if (this.state === 'PLAYING') this.checkCollision();

        // Particles
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }

    draw() {
        // BG
        this.ctx.fillStyle = '#34495e';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Grid
        this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        for(let x=0; x<this.width; x+=80) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); }
        for(let y=0; y<this.height; y+=80) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.width,y); }
        this.ctx.stroke();

        // Targets
        const showingHint = Date.now() < this.hintEndTime;
        
        this.targets.forEach(t => {
            t.pulse += 0.05;
            const isGoal = t.color.name === this.goalColor.name;
            const size = t.radius + Math.sin(t.pulse) * 2;
            
            this.ctx.beginPath();
            this.ctx.fillStyle = t.color.hex;
            this.ctx.arc(t.x, t.y, size, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.lineWidth = 4;
            this.ctx.strokeStyle = 'white';
            this.ctx.stroke();

            // Highlight Goal if Hint Active
            if (showingHint && isGoal) {
                this.ctx.lineWidth = 6;
                this.ctx.strokeStyle = '#FFEB3B';
                this.ctx.stroke();
                
                // Draw Arrow
                this.ctx.save();
                this.ctx.translate(this.player.x, this.player.y);
                const ang = Math.atan2(t.y - this.player.y, t.x - this.player.x);
                this.ctx.rotate(ang);
                this.ctx.fillStyle = '#FFEB3B';
                this.ctx.beginPath();
                this.ctx.moveTo(50, 0);
                this.ctx.lineTo(35, -10);
                this.ctx.lineTo(35, 10);
                this.ctx.fill();
                this.ctx.restore();
            }
        });

        // Player (Car)
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.rotate(this.player.angle);
        
        // Body
        this.ctx.fillStyle = '#f1c40f'; // Taxi yellow
        this.ctx.fillRect(-22, -18, 44, 36);
        // Roof
        this.ctx.fillStyle = '#2c3e50';
        this.ctx.fillRect(-8, -14, 20, 28);
        // Wheels
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(-18, -22, 12, 6);
        this.ctx.fillRect(-18, 16, 12, 6);
        this.ctx.fillRect(12, -22, 12, 6);
        this.ctx.fillRect(12, 16, 12, 6);
        // Lights
        this.ctx.fillStyle = '#fff';
        this.ctx.fillRect(18, -12, 6, 6);
        this.ctx.fillRect(18, 6, 6, 6);
        
        this.ctx.restore();

        // Particles
        this.particles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
            this.ctx.fill();
        });
        this.ctx.globalAlpha = 1;

        // Joystick Debug (Visual feedback)
        if (this.input.stick.active) {
            this.ctx.beginPath();
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.arc(this.input.origin.x, this.input.origin.y, this.input.radius, 0, Math.PI*2);
            this.ctx.fill();
            
            const kx = this.input.origin.x + this.input.stick.x * this.input.radius;
            const ky = this.input.origin.y + this.input.stick.y * this.input.radius;
            this.ctx.beginPath();
            this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
            this.ctx.arc(kx, ky, 25, 0, Math.PI*2);
            this.ctx.fill();
        }

        // Objective Text
        if (this.state === 'PLAYING') {
            this.ctx.fillStyle = "white";
            this.ctx.font = "bold 24px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 4;
            this.ctx.fillText("Find " + this.goalColor.name, this.width/2, 45);
            this.ctx.shadowBlur = 0;
        }
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// START
window.game = new Game();

</script>
</body>
</html>
